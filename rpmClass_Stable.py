import numpy as np
#import matplotlib
#matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as cl
from matplotlib.ticker import MaxNLocator
#from matplotlib.colors import Normalize
import copy
import os
from scipy.stats import norm
import matplotlib.animation as pla
import matplotlib.mlab as mlab



class ASI_RPM():
    '''
    Class for initialising the lattice be performing field sweeps, mainly
    return point memory
    '''
    def __init__(self, unit_cells_x, unit_cells_y, lattice = None, \
        bar_length = 220e-9, vertex_gap = 1e-7, bar_thickness = 25e-9, \
        bar_width = 80e-9, magnetisation = 800e3):
        self.lattice = lattice
        self.type = None
        self.Hc = None
        self.Hc_std = None
        self.previous = None
        self.unit_cells_x = unit_cells_x
        self.unit_cells_y = unit_cells_y
        self.side_len_x = None      #The side length is now defined in the square lattice
        self.side_len_y = None
        self.bar_length = bar_length
        self.vertex_gap = vertex_gap
        self.bar_width = bar_width
        self.bar_thickness = bar_thickness
        self.width = bar_width
        self.magnetisation = magnetisation
        self.unit_cell_len = (bar_length+vertex_gap)/2
        self.interType = 'dumbbell'


    def save(self, file, folder = os.getcwd()):
        '''
        Save existing arrays
        '''
        if folder == None:
            folder = os.getcwd()
        file = file.replace('.','p')
        parameters = np.array([self.unit_cells_x,self.unit_cells_y,\
            self.bar_length,self.vertex_gap,self.bar_width,\
            self.bar_thickness,self.magnetisation, self.side_len_x, self.side_len_y, self.type,\
            self.Hc, self.Hc_std])
        np.savez(os.path.join(folder,file), self.lattice, parameters)

    def load(self, file):
        '''
        load in existing arrays
        '''
        npzfile = np.load(file)
        parameters = npzfile['arr_1']
        print(len(parameters))
        self.unit_cells_x = np.int(parameters[0])
        self.unit_cells_y = np.int(parameters[1])
        self.bar_length = np.float(parameters[2])
        self.vertex_gap = np.float(parameters[3])
        self.bar_width = np.float(parameters[4])
        self.bar_thickness = np.float(parameters[5])
        self.magnetisation = np.float(parameters[6])
        self.side_len_x = np.int(parameters[7])
        self.side_len_y = np.int(parameters[8])
        self.type = parameters[9]
        if len(parameters) > 10:
            self.Hc = parameters[10]
            self.Hc_std = parameters[11]
        self.lattice = npzfile['arr_0']

    def loadSpinWrite(self, file):
        """
        load in spin writing array (generated by minesweeper writing gui, or other method)
        spin writing array is 2d with x,y position and a value 1 for spin reversal, 0 for no reversal
        then use that array to reverse selected spins of an existing lattice
        """    
        npfile = np.load(file)
        print("loaded")
        #parameters = npzfile['arr_1']
        print(npfile) 
        grid = self.lattice
        for y in range(npfile.shape[1]):
            for x in range(npfile.shape[0]):
                print("charge =", x,y,npfile[x,y]) 
                if grid[x,y,6] != 0:
                    if npfile[x,y] == 1:
                        print("magnetisation before =",grid[x,y,3:5])
                        grid[x,y,3:5] *= -1 
                        print("magnetisation after =",grid[x,y,3:5])
        grid[:,:,3:5][grid[:,:,3:5]==0.] = 0.



    '''
    These are the functions that define the lattice type and
    position of each of the bars:
        - Square
        - Tilted square
        - Kagome
        - Short shakti
        - Long shakti
        - Tetris
    The lattice is stored as a numpy array [x_position, y_position, z_position,
    x_magnetisation, y_magnetisation, z_magnetisation, coercive field,
    flip_count, vertex or not]
    '''
        
    def square(self, Hc_mean = 0.03, Hc_std = 0.05):
        '''
        Defines the lattice positions, magnetisation directions and coercive fields of an array of 
        square ASI
        Takes the unit cell from the initial defined parameters
        Generates a normally distributed range of coercive fields of the bars using Hc_mean and Hc_std as a percentage
        One thing to potentially change is to have the positions in nanometers
        '''
        self.type = 'square'
        self.Hc = Hc_mean                #Unit cell direction in x andy y
        self.Hc_std = Hc_std
        self.side_len_x = 2*self.unit_cells_x+1
        self.side_len_y = 2*self.unit_cells_y+1
        grid = np.zeros((2*self.unit_cells_x+1, 2*self.unit_cells_y+1, 9))        
        for x in range(0, 2*self.unit_cells_x+1):
            for y in range(0, 2*self.unit_cells_y+1):
                if (x+y)%2 != 0:
                    if y%2 == 0:
                        xpos = x*(self.bar_length+self.vertex_gap)/2
                        ypos = y*(self.bar_length+self.vertex_gap)/2
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,1.,0.,0., np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                    else:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,1.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                else:
                    if x%2 ==0 and x!=0 and y!=0 and x!=self.side_len_x-1 and y!=self.side_len_x-1:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,0])
                    else:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
        self.lattice = grid

    def tiltedSquare(self,theta, Hc_mean = 0.03, Hc_std = 0.05):
        '''
        Defines the lattice positions, magnetisation directions and coercive fields of an array of 
        square ASI
        Takes the unit cell from the initial defined parameters
        Generates a normally distributed range of coercive fields of the bars using Hc_mean and Hc_std as a percentage
        One thing to potentially change is to have the positions in nanometers
        '''
        self.type = 'tiltsquare'
        theta = np.pi*theta/180.
        self.side_len_x = 2*self.unit_cells_x+1            #Unit cell direction in x andy y
        self.side_len_y = 2*self.unit_cells_y+1
        grid = np.zeros((2*self.unit_cells_x+1, 2*self.unit_cells_y+1, 9))        
        for x in range(0, 2*self.unit_cells_x+1):
            for y in range(0, 2*self.unit_cells_y+1):
                if (x+y)%2 != 0:
                    if y%2 == 0:
                        if x%2 ==0:
                            grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,np.cos(theta),np.sin(theta),0., np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                        else:
                            grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,np.cos(theta),-np.sin(theta),0., np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                    else:
                        if x%2==0:
                            grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,-np.cos(theta),-np.sin(theta),0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                        else:
                            grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,-np.cos(theta),np.sin(theta),0., np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])

                else:
                    if x%2 ==0 and x!=0 and y!=0 and x!=self.side_len_x-1 and y!=self.side_len_x-1:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,0])
                    else:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
        self.lattice = grid

    def kagome(self, Hc_mean = 0.03, Hc_std = 0.05):
        '''
        Creates an array of Kagome ASI
        Takes the unit cell from the initial defined parameters
        Generates a normally distributed range of coercive fields of the bars using Hc_mean and Hc_std
        '''
        self.type = 'kagome'
        self.Hc = Hc_mean
        self.Hc_std = Hc_std
        xfactor = 2*np.cos(np.pi/6)
        yfactor = 2*np.sin(np.pi/6)
        self.side_len_x = 2*self.unit_cells_x+1            #Unit cell direction in x andy y
        self.side_len_y = 4*self.unit_cells_y+1
        grid = np.zeros((2*self.unit_cells_x+1, 4*self.unit_cells_y+1,9))
        xfactor = 2*np.cos(np.pi/6)
        yfactor = 2*np.sin(np.pi/6)
        test= 0.7071
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if x%2!=0 and y%2==0:
                    if (x-1)%4==0 and (y-2)%4==0:
                        if y%(self.side_len_y-1)!=0:
                            grid[x+1,y] = np.array([xfactor*(x+test)*self.unit_cell_len,(y)*self.unit_cell_len,0.,0.,0.,0.,0.,0, 0])
                            grid[x-1,y] = np.array([xfactor*(x-test)*self.unit_cell_len,(y)*self.unit_cell_len,0.,0.,0.,0.,0.,0, 0])
                        grid[x,y] = np.array([xfactor*x*self.unit_cell_len,(y)*self.unit_cell_len,0.,1.,0.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0, None])
                    elif (x-3)%4==0 and (y)%4==0:
                        if y%(self.side_len_y-1)!=0:
                            grid[x+1,y] = np.array([xfactor*(x+test)*self.unit_cell_len,(y)*self.unit_cell_len,0.,0.,0.,0.,0.,0, 0])
                            grid[x-1,y] = np.array([xfactor*(x-test)*self.unit_cell_len,(y)*self.unit_cell_len,0.,0.,0.,0.,0.,0, 0])
                        grid[x,y] = np.array([xfactor*x*self.unit_cell_len,y*self.unit_cell_len,0.,1.,0.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                    else:
                        grid[x,y] = np.array([xfactor*x*self.unit_cell_len,y*self.unit_cell_len,0.,0,0,0,0,0,None])
                elif x%2 ==0 and (y-1)%4==0:
                    if x%4==0:
                        grid[x,y] = np.array([xfactor*x*self.unit_cell_len,yfactor*y*self.unit_cell_len,0.,0.5,(3**0.5/2),0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                    else:
                        grid[x,y] = np.array([xfactor*x*self.unit_cell_len,yfactor*y*self.unit_cell_len,0.,-0.5,(3**0.5/2),0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                elif x%2 ==0 and (y-3)%4==0:
                    if x%4==0:
                        grid[x,y] = np.array([xfactor*x*self.unit_cell_len,yfactor*y*self.unit_cell_len,0.,-0.5,(3**0.5/2),0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                    else:
                        grid[x,y] = np.array([xfactor*x*self.unit_cell_len,yfactor*y*self.unit_cell_len,0.,0.5,(3**0.5/2),0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                else:
                    if np.array_equal(grid[x,y,0:2], [0., 0.]):
                        grid[x,y] = np.array([xfactor*x*self.unit_cell_len,y*self.unit_cell_len,0.,0,0,0,0,0,None])
        self.lattice = grid


    def shortShakti(self, Hc_mean = 0.03, Hc_std = 0.05):
        '''
        Creates a lattice of short shakti spin ice
        Takes the unit cell from the initislly defined parameters
        Uses a normal distribution for the coercive field of each bar
        '''
        self.type = 'short_shakti'
        self.side_len_x = 4*self.unit_cells_x+1            #Unit cell direction in x andy y
        self.side_len_y = 4*self.unit_cells_y+1
        grid = np.zeros((self.side_len_x, self.side_len_y, 9))        
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if (x+y)%2 != 0:
                    if y%2 == 0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,1.,0.,0., np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                    else:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,1.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                else:
                    if x%2 ==0:     # and y%(self.side_len_y-1)!=0 and x%(self.side_len_x-1)!=0
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,0])
                    else:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if (y-2)%8==0:
                    if (x-1)%8==0 or (x-3)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (y-6)%8==0:
                    if (x-5)%8==0 or (x-7)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-2)%8==0:
                    if (y-5)%8==0 or (y-7)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-6)%8==0:
                    if (y-1)%8==0 or (y-3)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
        self.lattice = grid


    def longShakti(self, Hc_mean = 0.062, Hc_std = 0.05):
        '''
        Creates a lattice of long shakti spin ice
        Takes the unit cell from the initislly defined parameters
        Uses a normal distribution for the coercive field of each bar
        '''
        self.type = 'long_shakti'
        self.Hc = Hc_mean
        self.Hc_std = Hc_std
        self.side_len_x = 4*self.unit_cells_x+1            #Unit cell direction in x andy y
        self.side_len_y = 4*self.unit_cells_y+1
        grid = np.zeros((self.side_len_x, self.side_len_y, 9))        
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if (x+y)%2 != 0:
                    if y%2 == 0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,1.,0.,0., np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                    else:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,1.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                else:
                    if x%2 ==0:     
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,0])
                    else:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if (y-2)%8==0:
                    if (x-1)%8==0 or (x-3)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (y-6)%8==0:
                    if (x-5)%8==0 or (x-7)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-2)%8==0:
                    if (y-5)%8==0 or (y-7)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-6)%8==0:
                    if (y-1)%8==0 or (y-3)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if (y-2)%8==0:
                    if (x-5)%8==0 or (x-7)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    if (x-6)%8==0:
                        grid[x,y] = np.array([(x)*self.unit_cell_len,y*self.unit_cell_len,0.,2.,0.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                if (y-6)%8==0:
                    if (x-1)%8==0 or (x-3)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    if (x-2)%8==0:
                        grid[x,y] = np.array([(x)*self.unit_cell_len,y*self.unit_cell_len,0.,2.,0.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                if (x-2)%8==0:
                    if (y-1)%8==0 or (y-3)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    if (y-2)%8==0:
                        grid[x,y] = np.array([(x)*self.unit_cell_len,y*self.unit_cell_len,0.,0.,2.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                if (x-6)%8==0:
                    if (y-5)%8==0 or (y-7)%8==0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    if (y-6)%8==0:
                        grid[x,y] = np.array([(x)*self.unit_cell_len,y*self.unit_cell_len,0.,0.,2.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
        self.lattice = grid

    def tetris(self, Hc_mean = 0.03, Hc_std = 0.05):
        '''
        Creates a lattice of tertris artificial spin ice
        Takes the unit cell from the initislly defined parameters
        Uses a normal distribution for the coercive field of each bar
        '''
        self.type = 'tetris'
        self.Hc = Hc_mean
        self.Hc_std = Hc_std
        self.side_len_x = 16*self.unit_cells_x+1            #Unit cell direction in x andy y
        self.side_len_y = 16*self.unit_cells_y+1
        grid = np.zeros((self.side_len_x, self.side_len_y, 9))        
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if (x+y)%2 != 0:
                    if y%2 == 0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,1.,0.,0., np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                    else:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,1.,0.,np.random.normal(loc=Hc_mean, scale=Hc_std*Hc_mean, size=None),0,None])
                else:
                    if x%2 ==0:     # and y%(self.side_len_y-1)!=0 and x%(self.side_len_x-1)!=0:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,0])
                    else:
                        grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if (x)%16==0 and (y-5)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x)%16==0 and (y-1)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-1)%16==0 and (y-2)%8==0:
                    grid[x,y] = np.array([(x+1)*self.unit_cell_len,(y+1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+1,y-1] = np.array([(x+2)*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-2)%16==0 and (y-7)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+1,y-1] = np.array([(x+1)*self.unit_cell_len,(y-1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+2,y] = np.array([(x+2)*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-4)%16==0 and (y-3)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+1,y+1] = np.array([(x+1)*self.unit_cell_len,(y+1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+2,y] = np.array([(x+2)*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-7)%16==0 and (y)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])    
                if (x-6)%16==0 and (y-1)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+2,y] = np.array([(x+2)*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-9)%16==0 and (y-6)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x-1,y-1] = np.array([x*self.unit_cell_len,(y-1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+1,y-1] = np.array([(x+1)*self.unit_cell_len,(y-1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-11)%16==0 and (y-2)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x-1,y+1] = np.array([x*self.unit_cell_len,(y+1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+1,y+1] = np.array([(x+1)*self.unit_cell_len,(y+1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-13)%16==0 and (y)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x-1,y-1] = np.array([x*self.unit_cell_len,(y-1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+1,y-1] = np.array([(x+1)*self.unit_cell_len,(y-1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                if (x-14)%16==0 and (y-5)%8==0:
                    grid[x,y] = np.array([x*self.unit_cell_len,y*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
                    grid[x+1,y-1] = np.array([(x+1)*self.unit_cell_len,(y-1)*self.unit_cell_len,0.,0.,0.,0.,0,0,None])
        self.lattice = grid

    '''
    Graphing the state of the lattice
        - graph: Plots a quiver graph that shows the Coercive field, counts and vertex state
        - Graph charge: Plots a quiver with the charge of the vertex for kagome and tetris
        - Correlation: Plots the local corration between spins based on the surrounding microstates
        - Field Plot: Plots the local field at each point on the lattice and vertex. Colour is 
                    proportional to the strength of the field
        - Vertex Type: Plots the vertex type for a square lattice
        - Animation: Can give a field sweep field and it will display an animation of 
                    how the bars flip over the field sweep
    '''


    def graph(self):
        '''
        Plots the positions and directions of the bar magnetisations as a quiver graph
        '''
        grid = self.lattice
        X = grid[:,:,0].flatten()
        Y = grid[:,:,1].flatten()
        z = grid[:,:,2].flatten()
        Mx = grid[:,:,3].flatten()
        My = grid[:,:,4].flatten()
        Mz = grid[:,:,5].flatten()
        Hc = grid[:,:,6].flatten()
        C = grid[:,:,7].flatten()
        Charge = grid[:,:,8].flatten()
        fig, ax =plt.subplots(ncols = 2,sharex=True, sharey=True)
        plt.set_cmap(cm.plasma)
        graph = ax[0].quiver(X, Y, Mx, My, Hc, angles='xy', scale_units='xy',  pivot = 'mid')
        ax[0].set_xlim([-1*self.unit_cell_len, np.max(X)+self.unit_cell_len])
        ax[0].set_ylim([-1*self.unit_cell_len, np.max(X)+self.unit_cell_len])
        ax[0].set_title('Coercive Field')
        cb1 = fig.colorbar(graph, fraction=0.046, pad=0.04, ax = ax[0], format='%.2e',boundaries = np.linspace(np.min(Hc[np.nonzero(Hc)]), max(Hc),1000))
        cb1.locator = MaxNLocator(nbins = 7)
        cb1.update_ticks()
        graph = ax[1].quiver(X, Y, Mx, My, C, angles='xy', scale_units='xy',  pivot = 'mid')
        ax[1].set_xlim([-1*self.unit_cell_len, np.max(X)+self.unit_cell_len])
        ax[1].set_ylim([-1*self.unit_cell_len, np.max(Y)+self.unit_cell_len])
        ax[1].set_title('Counts')
        cb2 = fig.colorbar(graph, fraction=0.046, pad=0.04, ax = ax[1])
        cb2.locator = MaxNLocator( nbins = 5)
        cb2.update_ticks()
        for axes in ax:
            axes.plot([1, 2, 3], [1, 2, 3])
            axes.set(adjustable='box-forced', aspect='equal')
            plt.gca().xaxis.set_major_locator( MaxNLocator(nbins = 7, prune = 'lower') )
            plt.gca().yaxis.set_major_locator( MaxNLocator(nbins = 6) )
        plt.ticklabel_format(style='sci', scilimits=(0,0))
        plt.tight_layout()
        #fig, ax_ver =plt.subplots()
        #plt.scatter(X, Y, c = Charge)
        #plt.quiver(X, Y, Mx, My, C, angles='xy', scale_units='xy',  pivot = 'mid')
        #ax_ver.set_xlim([-1*self.unit_cell_len, np.max(X)])
        #ax_ver.set_ylim([-1*self.unit_cell_len, np.max(Y)])
        #ax_ver.set(adjustable='box-forced', aspect='equal')
        #plt.ticklabel_format(style='sci', scilimits=(0,0))
        #plt.tight_layout()
        #return(graph)
        plt.show()

    def graphCharge(self):
        '''
        Plots the positions and directions of the bar magnetisations as a quiver graph
        '''
        self.vertexCharge2()
        grid = self.lattice
        X = grid[:,:,0].flatten()
        Y = grid[:,:,1].flatten()
        z = grid[:,:,2].flatten()
        Mx = grid[:,:,3].flatten()
        My = grid[:,:,4].flatten()
        Mz = grid[:,:,5].flatten()
        Hc = grid[:,:,6].flatten()
        C = grid[:,:,7].flatten()
        MagCharge = grid[:,:,8].flatten()
        
        fig = plt.figure(figsize=(6,6))
        ax = fig.add_subplot(111)
        ax.set_xlim([-1*self.unit_cell_len, np.max(X)+self.unit_cell_len])
        ax.set_ylim([-1*self.unit_cell_len, np.max(Y)+self.unit_cell_len])
        ax.set_title("Vertex Magnetic Charge Map",fontsize=14)
        #ax.set_xlabel("XAVG",fontsize=12)
        #ax.set_ylabel("YAVG",fontsize=12)
        #ax.grid(True,linestyle='-',color='0.75')

        ax.quiver(X, Y, Mx, My, angles='xy', scale_units='xy',  pivot = 'mid', zorder=1)
        # scatter with colormap mapping to z value
        ax.scatter(X,Y,s=80,c=MagCharge, marker = 'o', cmap = cm.seismic, zorder=2, edgecolor='k' );
        ax.set(adjustable='box-forced', aspect='equal')
        plt.ticklabel_format(style='sci', scilimits=(0,0))
        plt.tight_layout()
        plt.show()
        #Y2 = grid[:,:,1].flatten()
        #Charge = grid[:,:,8].flatten()
        #Charge = np.array(Charge, dtype = np.double)
        #Charge[ Charge == 0] = np.nan
        #cmap = matplotlib.cm.get_cmap('viridis')
        #normalize = matplotlib.colors.Normalize(vmin=min(MagCharge), vmax=max(MagCharge))
        #colors = [cmap(normalize(value)) for value in MagCharge]
        #ax = plt.gca()
        #fig, ax =plt.subplots(ncols = 2,sharex=True, sharey=True)
        #plt.set_cmap(cm.jet)
        
        #ax.scatter(X2,Y2,color=colors)
        #ax.set_xlim([-1*self.unit_cell_len, self.side_len_x*self.unit_cell_len])
        #ax.set_ylim([-1*self.unit_cell_len, self.side_len_y*self.unit_cell_len])
        #ax.set_title('Vertex Charge Map')

    def fieldPlot(self, n=5):
        '''
        Plots the field direction and magnitude at each point on the graph
        '''
        grid = self.lattice
        field = np.zeros((self.side_len_x,self.side_len_y,3))
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                field[x,y,:] = self.Hlocal2(x, y, n=n)
        X = grid[:,:,0].flatten()
        Y = grid[:,:,1].flatten()
        Hx = field[:,:, 0].flatten()
        Hy = field[:,:, 1].flatten()
        Hz = field[:,:, 2].flatten()
        fieldMag = (Hx**2+Hy**2+Hz**2)**0.5
        fig, ax =plt.subplots(ncols = 2,sharex=True, sharey=True)
        plt.set_cmap(cm.plasma)
        graph = ax[0].quiver(X, Y, Hx, Hy,fieldMag, angles='xy', scale_units='xy',  pivot = 'mid')
        cb2 = fig.colorbar(graph, fraction=0.046, pad=0.04, ax = ax[1])
        cb2.locator = MaxNLocator(nbins = 5)
        #qk = ax[0].quiverkey(graph, 0.45, 0.9, 10, r'$mT$', labelpos='E',
        #           coordinates='figure')
        ax[0].set_xlim([-1*self.unit_cell_len, np.max(X)+self.unit_cell_len])
        ax[0].set_ylim([-1*self.unit_cell_len, np.max(Y)+self.unit_cell_len])
        ax[0].set_title('In Plane Field')
        #fig.colorbar(graph, ax = ax[0],boundaries = np.linspace(np.min(Hc[np.nonzero(Hc)]), max(Hc),1000))
        graph = ax[1].scatter(X, Y, Hz, marker='o', )
        ax[1].set_xlim([-1*self.unit_cell_len, np.max(X)+self.unit_cell_len])
        ax[1].set_ylim([-1*self.unit_cell_len, np.max(Y)+self.unit_cell_len])
        ax[1].set_title('Out of Plane Field')
        for axes in ax:
            axes.plot([1, 2, 3], [1, 2, 3])
            axes.set(adjustable='box-forced', aspect='equal')
        plt.ticklabel_format(style='sci', scilimits=(0,0))
        plt.tight_layout()
        print(Hz)
        #fig.colorbar(graph, ax = ax[0],boundaries = np.linspace(np.min(Hz), max(Hz),1000))
        plt.draw()
        plt.show()

    def vertexTypeMap(self):
        '''
        Plots a quiver graph of the state of the lattice with the type of vertice for a square lattice
        Only works with square
        '''
        Vertex = self.vertexType()
        X = self.lattice[:,:,0].flatten()
        Y = self.lattice[:,:,1].flatten()
        z = self.lattice[:,:,2].flatten()
        Mx = self.lattice[:,:,3].flatten()
        My = self.lattice[:,:,4].flatten()
        Mz = self.lattice[:,:,5].flatten()
        Hc = self.lattice[:,:,6].flatten()
        C = self.lattice[:,:,7].flatten()
        charge = self.lattice[:,:,8].flatten()
        Type = Vertex[:,:,4].flatten()
        fig = plt.figure(figsize=(6,6))
        ax = fig.add_subplot(111)
        ax.set_xlim([-1*self.unit_cell_len, np.max(X)+self.unit_cell_len])
        ax.set_ylim([-1*self.unit_cell_len, np.max(Y)+self.unit_cell_len])
        graph = ax.scatter(X,Y,c = Vertex[:,:,4], marker = 'o', cmap = cm.plasma, zorder=2)
        cb2 = fig.colorbar(graph, fraction=0.046, pad=0.04, ax = ax)
        cb2.locator = MaxNLocator(nbins = 5)
        cb2.update_ticks()
        ax.quiver(X,Y,Mx,My,angles='xy', scale_units='xy',  pivot = 'mid')
        plt.show()

    def localPlot(self,x,y,n):
        '''
        Will plot the lattice with bars with n radius of position x,y 
        plotted in bold. Useful for seeing where the n nearest bars are
        '''
        x1 = x - n
        x2 = x + n+1
        y1 = y - n
        y2 = y + n+1
        
        if x1<0:
            x1 = 0
        if x2>self.side_len_x:
            x2 = self.side_len_x -1
        if y1<0:
            y1 = 0
        if y2>self.side_len_y-1:
            y2 = self.side_len_y-1

        local = self.lattice[x1:x2,y1:y2,:]
        grid = self.lattice
        plt.quiver(grid[:,:,0].flatten(), grid[:,:,1].flatten(),grid[:,:,3].flatten(),grid[:,:,4].flatten(), angles='xy', scale_units='xy',  pivot = 'mid')
        #plt.scatter(grid[:,:,0].flatten(), grid[:,:,1].flatten(), c = grid[:,:,8].flatten())
        plt.plot(grid[x,y,0],grid[x,y,1], 'o')
        plt.quiver(local[:,:,0].flatten(), local[:,:,1].flatten(),local[:,:,3].flatten(),local[:,:,4].flatten(), angles='xy', scale_units='xy',  pivot = 'mid', color = 'b')
        plt.show()


    def animateGraph(self):
        '''
        Returns an image of the state of the lattice with the count as colour of the arrows
        To be used in combination with another fieldSweepAnimation function
        '''
        grid = self.lattice
        X = grid[:,:,0].flatten()
        Y = grid[:,:,1].flatten()
        z = grid[:,:,2].flatten()
        Mx = grid[:,:,3].flatten()
        My = grid[:,:,4].flatten()
        Mz = grid[:,:,5].flatten()
        Hc = grid[:,:,6].flatten()
        C = grid[:,:,7].flatten()
        im = plt.quiver(X, Y, Mx, My, C, angles='xy', scale_units='xy',  pivot = 'mid')
        return(im)

    def fieldSweepAnimation(self, folder, name = 'Lattice_counter'):
        '''
        Will produce an animation of the lattice as it goes through the field sweep
        just provide the folder where the field sweeps are saved
        '''
        ims = []
        counter = []
        fig_anim = plt.figure('Animation')
        for root, dirs, files in os.walk(folder):
            for file in files:
                if name in file:
                    print(file)
                    self.clearLattice()
                    self.load(os.path.join(root, file))
                    im = self.animateGraph()
                    print((file[15:17].replace('_', '')))
                    counter.append((file[15:17].replace('_', '')))
                    ims.append([im])
        #sorted_ims = [x for _,x in sorted(zip(counter,ims))]
        anim = pla.ArtistAnimation(fig_anim, ims, interval = 1000, blit = True, repeat_delay = 1000)
        plt.show()

    def resetCount(self):
        '''
        Resets the count parameter in the lattice
        '''
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                self.lattice[x,y,7] = 0
    
    def subtractCount(self, lattice1, lattice2):
        '''
        Should take two instances of the ASI_RPM class and then return the difference between the number of spins flipped
        '''
        l1 = lattice1.returnLattice()
        l2 = lattice2.returnLattice()
        diff = l2[:,:,7] - l1[:,:,7]
        #print(diff)
        l1[:,:,7] = diff
        return(self(self.unit_cells_x, self.unit_cells_y,lattice = diff))

    def magneticOrdering(self):
        '''
        Performs a fourier transform of the lattice and returns a graph of the 
        amplitude in k-space
        '''
        plt.set_cmap(cm.plasma)
        grid = self.lattice
        #grid[grid[:,:,6] == 0] = np.nan
        X = grid[:,:,0]
        Y = grid[:,:,1]
        Mx = grid[:,:,3]
        My = grid[:,:,4]
        M_vect = Mx+1j*My
        Mag_fft = np.fft.fft2(M_vect)
        kx = np.fft.fftfreq(self.side_len_x, self.unit_cells_x)
        ky = np.fft.fftfreq(self.side_len_x, self.unit_cells_y)
        Mag_fftR = np.real(Mag_fft)
        Mag_fftI = np.imag(Mag_fft)
        Mag_fftA = np.absolute(Mag_fft)
        print(Mag_fft**2)
        extent = [min(kx), max(kx), min(ky), max(ky)]

        plt.imshow(Mag_fftA, extent = extent)
        plt.colorbar()
        plt.show()
    
    def relax(self, Happlied = np.array([0.,0.,0.]), n=10):
        '''
        Steps through all the the positions in the lattice and if the field applied along the direction
        of the bar is negative and greater than the coercive field then it switches the magnetisation
        of the bar
        '''
        grid = copy.deepcopy(self.lattice)
        unrelaxed = True
        Happlied[Happlied == -0.] = 0.
        while unrelaxed == True:
            flipcount = 0
            for x in range(0, self.side_len_x):
                for y in range(0, self.side_len_y):
                    if abs(grid[x,y,6]) != 0:
                        unit_vector = grid[x,y,3:6]
                        field = np.dot(np.array(Happlied+self.Hlocal2(x,y, n=n)), unit_vector)
                        #print(field)
                        if field < -grid[x,y,6]:
                            #print(grid[x,y,3:5])
                            grid[x,y,3:5] = np.negative(grid[x,y,3:5])
                            #print(grid[x,y,3:5])
                            grid[x,y,:][grid[x,y,:]==0.] = 0.
                            grid[x,y,7] += 1
                            flipcount += 1
                            #print(grid[x,y,3:5])
            print("no of flipped spins in relax", flipcount)
            grid[grid==-0.] = 0.
            if flipcount > 0:
                unrelaxed = True
            else:
                unrelaxed = False
            self.lattice = grid
    
    
    def fieldSweep(self, Hmax, steps, Htheta, n=10, loops=1, folder = None, q1 = False):
        '''
        Sweeps through from 90% of the minimum Coercive field to Hmax at angle Htheta in steps. 
        Total number of steps for a full minor loop is 4*(step+1).
        The function then performs loops number of minor loops
        The Lattice after each field step gets saved to a folder. if folder is None then the 
        function saves the lattice to the current working directory
        '''
        M0 = copy.deepcopy(self)
        testLattice = copy.deepcopy(self.lattice)

        Htheta = np.pi*Htheta/180
        testLattice[testLattice[:,:,6] == 0] = np.nan
        Hc_min = np.nanmin(testLattice[:,:,6])
        
        q = []
        mag = []
        monopole = []
        fieldloops = []
        vertex = []
        field_steps = np.linspace(Hc_min*0.9,Hmax,steps+1)
        field_steps = np.append(field_steps, np.linspace(Hmax,Hc_min*0.9,steps+1))
        field_steps = np.append(field_steps, np.linspace(-(Hc_min*0.9),-Hmax,steps+1))
        field_steps = np.append(field_steps, np.linspace(-Hmax,-(Hc_min*0.9),steps+1))
        print(field_steps)
        counter = 0
        if folder == None:
            self.save('InitialRPMLattice_Hmax%(Hmax)e_steps%(steps)d_Angle%(Htheta)e_neighbours%(n)d_Loops%(loops)d' % locals(), folder = folder)
        else:
            if not os.path.exists(folder):
                os.makedirs(folder)
            self.save('InitialRPMLattice_Hmax%(Hmax)e_steps%(steps)d_Angle%(Htheta)e_neighbours%(n)d_Loops%(loops)d' % locals(), folder = folder)
        for i in range(0, loops):
            self.previous = copy.deepcopy(self)
            for j in field_steps:
                Happlied = j*np.array([np.cos(Htheta),np.sin(Htheta), 0.])
                print('Happlied: ', Happlied)
                print()
                self.relax(Happlied,n)
                fieldloops.append(np.array([i, j]))
                mag.append(self.netMagnetisation())
                monopole.append(self.monopoleDensity())
                q.append(self.correlation(self.previous,self))
                #vertex.append(self.vertexTypePercentage())
                if folder == None:
                    self.save('Lattice_counter%(counter)d_Loop%(i)d_FieldApplied%(j)e_Angle%(Htheta)e' % locals())
                else:
                    if not os.path.exists(folder):
                        os.makedirs(folder)
                    self.save('Lattice_counter%(counter)d_Loop%(i)d_FieldApplied%(j)e_Angle%(Htheta)e' % locals(), folder = folder)
                counter+=1
            if q1 == True:
                if q[-1]==1:
                    break
        self.save('FinalRPMLattice_Hmax%(Hmax)e_steps%(steps)d_Angle%(Htheta)e_neighbours%(n)d_Loops%(loops)d' % locals(), folder = folder)
        fieldloops = np.array(fieldloops)
        q = np.array(q)
        mag = np.array(mag)
        monopole = np.array(monopole)
        vertex = np.array(vertex)
        file = 'RPMStateInfo_Hmax%(Hmax)e_steps%(steps)d_Angle%(Htheta)e_neighbours%(n)d_Loops%(loops)d' % locals()
        parameters = np.array([Hmax, steps, Htheta, n, loops, self.Hc, self.Hc_std])
        print(parameters)
        if folder == None:
            folder = os.getcwd()
            np.savez(os.path.join(folder, file), parameters, fieldloops, q, mag, monopole, vertex)
        else:
            np.savez(os.path.join(folder, file), parameters, fieldloops, q, mag, monopole, vertex)

    def FORC(self, Hmin, Hmax, deltaH, Htheta, n=4, folder = None):
        M0 = copy.deepcopy(self)
        testLattice = copy.deepcopy(self.lattice)

        Htheta = np.pi*Htheta/180
        testLattice[testLattice[:,:,6] == 0] = np.nan
        Hc_min = np.nanmin(testLattice[:,:,6])
        x = np.linspace(0, 2*np.pi, 1000)
        y = -0.5*x*np.sin(x)
        plt.plot(x, y)



    def appliedFieldSweep(self, Hmin, Hmax, Hsteps, steps, Htheta, n=4, loops=5, folder = None):
        '''
        Will do a range of applied field sweeps 
        '''
        Hrange = np.linspace(Hmin, Hmax, Hsteps)
        for H in Hrange:
            if folder == None:
                newfolder = os.getcwd()+'\\Hmax'+str(H/self.Hc)+'\\'
            else:
                newfolder = folder+'\\Hmax'+str(H/self.Hc)+'\\'
            print(folder)
            self.fieldSweep(H, steps, Htheta, n=n, loops = loops, folder = newfolder, q1 = True)
        np.savez(os.path.join(folder, 'StateCode'), np.array(Hrange))

    def searchRPM_monte(self, samples, Hmax, Htheta = 45, steps =10, n=3,loops=4, folder = None):
        '''
        For randomise the starting state of the lattice and then 
        it will then perform a field sweep until RPM behaviour is observed or the number of loops (loops) is exceded
        The field sweep parameters are specified by:
        Hmax = the maximum field to be applied
        Htheta = the direction which the field will be applied in (measured in degrees)
        steps = the number of field steps between 0 and Hmax
        n = the number of nearest neighbours to be considered
        loops =  the number of minor field loops that will be cycled through in each sweep

        This will repeat for everypoint on the lattice. Saving the lattice at each field step
        '''
        label = np.arange(0,samples)
        for state in label:
            self.randomMag()
            if folder == None:
                newfolder = os.getcwd()+'\\State'+str(state)+'\\'
            else:
                newfolder = folder+'\\State'+str(state)+'\\'
            self.fieldSweep(Hmax, steps, Htheta, n=n, loops = loops, folder = newfolder, q1 = True)
        np.savez(os.path.join(folder, 'StateCode'), np.array(label))

    def searchRPM_single(self, Hmax, Htheta = 45, steps =10, n=3, loops=4, folder = None):
        '''
        Will flip a single bar at each point on the lattice
        it will then perform a field sweep until RPM behaviour is observed or the number of loops (loops) is exceded
        The field sweep parameters are specified by:
        Hmax = the maximum field to be applied
        Htheta = the direction which the field will be applied in (measured in degrees)
        steps = the number of field steps between 0 and Hmax
        n = the number of nearest neighbours to be considered
        loops =  the number of minor field loops that will be cycled through in each sweep

        This will repeat for everypoint on the lattice. Saving the lattice at each field step
        '''
        positions = []
        if folder == None:
            self.save('InitialState', os.getcwd())
        else:
            self.save('InitialState', folder)
        for x in np.arange(0, self.side_len_x):
            for y in np.arange(0, self.side_len_y):
                if self.lattice[x,y,6]!=0:
                    positions.append([x,y])
                    if folder == None:
                        newfolder = os.getcwd()+'\\x'+str(x)+'y'+str(y)+'\\'
                    else:
                        newfolder = folder+'\\x'+str(x)+'y'+str(y)+'\\'
                    self.load(os.path.join(folder+r'\InitialState.npz'))
                    self.flipSpin(x,y)
                    self.fieldSweep(Hmax, steps, Htheta, n=n, loops = loops, folder = newfolder, q1 = True)
        np.savez(os.path.join(folder, 'StateCode'), np.array(positions))
    
    def searchRPM_multiple(self, samples, flips, Hmax, Htheta = 45, steps =10, n=3,loops=4, folder = None):
        '''
        Will flip a number of bars magnetisation direction given by the variable flips at random positions on the lattice
        it will then perform a field sweep until RPM behaviour is observed or the number of loops (loops) is exceded
        The field sweep parameters are specified by:
        Hmax = the maximum field to be applied
        Htheta = the direction which the field will be applied in (measured in degrees)
        steps = the number of field steps between 0 and Hmax
        n = the number of nearest neighbours to be considered
        loops =  the number of minor field loops that will be cycled through in each sweep

        This will then be repeated on the same initial starting state the number of times speficied by samples
        '''
        if folder == None:
            self.save('InitialState', os.getcwd())
        else:
            self.save('InitialState', folder)
        positions = []
        for state in np.arange(0, samples):
            self.load(folder+r'InitialState')
            switch = 0
            flip_loc = []
            while switch<flips:
                x = np.random.randint(0, self.side_len_x)
                y = np.random.randint(0, self.side_len_y)
                if grid[x,y,6]!=0:
                    self.flipSpin(x,y)
                    switch+=1
                    flip_loc.append([x,y])
            positions.append(flip_loc)
            if folder == None:
                newfolder = os.getcwd()+'\\x'+str(x)+'y'+str(y)+'\\'
            else:
                newfolder = folder+'\\x'+str(x)+'y'+str(y)+'\\'
            self.fieldSweep(Hmax, steps, Htheta, n=n, loops = loops, folder = newfolder, q1 = True)
        np.savez(os.path.join(folder, 'StateCode'), np.array(positions))

    def analysisAppliedFieldSweep(self, folder):
        statecode = np.load(os.path.join(folder, 'StateCode.npz'))
        
        lattice_list = []
        for root, dirs, files in os.walk(folder):
            for file in files:
                if 'FinalRPMLattice' in file:
                    self.load(os.path.join(root, file))
                    lattice_list.append(copy.deepcopy(self))
        corr_list = np.zeros((len(lattice_list), len(lattice_list)))
        i = 0
        for l1 in lattice_list:
            j = 0
            for l2 in lattice_list:
                corr_list[i, j] = (self.correlation(l1, l2))
                j+=1
            i+=1
        fig = plt.figure()
        ax = fig.add_subplot(111)
        heatmap = ax.pcolor(statecode*1000, statecode*1000,corr_list)
        plt.xlabel('Microstate for Minor Loop with maximum applied field (mT)')
        plt.ylabel('Microstate for Minor Loop with maximum applied field (mT)')       

        plt.colorbar(heatmap)
        plt.title('Correlation between all final states')
        fig = plt.figure()
        ax = fig.add_subplot(111)
        linegraph = ax.plot(statecode*1000,corr_list[-1,:], '.')
        plt.xlabel('Maximum magnetic field (mT)')
        plt.ylabel('Correlation relative to lowest magnetic field RPM state')
        plt.show()

    def analysisSingleFlip(self, folder):
        '''
        Will analyse the results from the singleFlip function
        Put the folder location of the single flip
        '''
        statecode = np.load(os.path.join(folder, 'StateCode.npz'))
        print(os.path.join(folder, 'InitialState.npz'))
        statecode = np.array(statecode['arr_0'])
        self.load(os.path.join(folder, 'InitialState.npz'))
        Initial = self       

        lattice_list = []
        for root, dirs, files in os.walk(folder):
            for file in files:
                if 'FinalRPMLattice' in file:
                    self.load(os.path.join(root, file))
                    lattice_list.append(copy.deepcopy(self))
        corr_list = np.zeros((len(lattice_list), len(lattice_list)))
        
        corr_compare = []
        i = 0
        for l1 in lattice_list:
            j = 0
            for l2 in lattice_list:
                if l1 == l2:
                    break
                else:
                    corr_list[i, j] = (self.correlation(l1, l2))
                    j+=1
            if i!=0:
                corr_compare.append(self.correlation(l1,Initial))
            i+=1
        fig = plt.figure()
        ax = fig.add_subplot(111)
        #print(statecode.shape)
        #print(corr_list.shape)
        #print(statecode[:,0])
        #print(statecode[:,1])
        battleship = plt.scatter(statecode[:,0], statecode[:,1], c = np.array(corr_compare))
        plt.colorbar(battleship)
        plt.xlabel('x position')
        plt.ylabel('y position')
        plt.title('Correlation to initial perturbation after single flip')
        Hc = []
        Hc_eff = []
        for pos,lattice in zip(statecode, lattice_list):
            Hc.append(self.returnLattice()[pos[0], pos[1], 6])
            self = lattice
            Hc_eff.append(self.effectiveCoercive(pos[0], pos[1], 4))
        plt.figure()
        plt.plot(np.array(Hc)*1000, corr_compare, '.')
        plt.xlabel('Coercive field (mT) of bar flipped')
        plt.ylabel('Correlation relative to initial RPM state')
        plt.title('Correlation against coercive field of bar flipped')
        plt.figure()
        plt.plot(np.array(Hc_eff)*1000, corr_compare, '.')
        plt.xlabel('Effective Coercive field (mT) of bar flipped')
        plt.ylabel('Correlation relative to initial RPM state')
        plt.title('Correlation against coercive field of bar flipped')
        plt.show()
              
    def analysisMC(self, folder):
        '''
        Analyses the results from a Monte Carlo initial RPM states
        '''
        statecode = np.load(os.path.join(folder, 'StateCode.npz'))
        print(os.path.join(folder, 'InitialState.npz'))
        statecode = np.array(statecode['arr_0'])
        self.load(os.path.join(folder, 'InitialState.npz'))
        Initial = self
        print(Initial)
        print(len(statecode))
        Hc_list = Initial.returnLattice()[:,:,6]
        Hc_list[Hc_list==0] = np.nan
        Hc_list = Hc_list.flatten()
        
        Hc_list = Hc_list[~np.isnan(Hc_list)]
        print(Hc_list)
        lattice_list = []
        lattice_init = []

        for root, dirs, files in os.walk(folder):
            for file in files:
                if 'FinalRPMLattice' in file:
                    self.load(os.path.join(root, file))
                    lattice_list.append(copy.deepcopy(self))
                if 'InitialRPMLattice' in file:
                    self.load(os.path.join(root, file))
                    lattice_init.append(copy.deepcopy(self))
        corr_list = np.zeros((len(lattice_list), len(lattice_list)))
        corr_init = np.zeros((len(lattice_list), len(lattice_list)))
        corr_compare = []
        i = 0
        for l1,l3 in zip(lattice_list,lattice_init):
            j = 0
            for l2,l4 in zip(lattice_list, lattice_init):
                corr_list[i, j] = (self.correlation(l1, l2))
                corr_init[i,j] = (self.correlation(l3,l4))
                j+=1
            i+=1
        fig = plt.figure()
        ax = fig.add_subplot(111)
        print(statecode.shape)
        battleship = plt.pcolor(corr_list)
        plt.colorbar(battleship)
        plt.xlabel('Random initial microstate sample number')
        plt.ylabel('Random initial microstate sample number')
        plt.title('Correlation between final RPM states')
        plt.figure()
        plt.plot(corr_init.flatten(), corr_list.flatten(), '.')
        plt.xlabel('Initial correlation between states')
        plt.ylabel('Final correlation between states')
        plt.title('Correlation between initial and final States')
        plt.show()

        

    def clearLattice(self):
        '''
        Clears the lattice
        '''
        self.lattice = None
    
    
    def dumbbell(self, m, r, r0):
        '''
        Uses the dumbbell model to calculate the interaction between
        each bar
        '''
        m = np.array(m)
        r = np.array(r)
        r0 = np.array(r0)

        mag_charge = self.bar_thickness*self.magnetisation*self.bar_width

        r2 = np.subtract(np.transpose(r), r0).T + m*self.bar_length/2
        r1 = np.subtract(np.transpose(r), r0).T - m*self.bar_length/2
        B = 1e-7*mag_charge*(r1/np.linalg.norm(r1)**3-r2/np.linalg.norm(r2)**3)
        return(B)

    def dipole(self, m, r, r0):
        """
        Calculate a field in point r created by a dipole moment m located in r0.
        Spatial components are the outermost axis of r and returned B.
        """
        m = np.array(m)
        r = np.array(r)
        r0 = np.array(r0)
        m = self.magnetisation*self.bar_length*self.bar_width*self.bar_thickness*m
        #print(r,r0)
        #r = (self.vertex_gap+self.bar_length/2)*r
        #r0 = (self.vertex_gap+self.bar_length/2)*r0
        # we use np.subtract to allow r and r0 to be a python lists, not only np.array
        R = np.subtract(np.transpose(r), r0).T
        # assume that the spatial components of r are the outermost axis
        norm_R = np.sqrt(np.einsum("i...,i...", R, R))
        # calculate the dot product only for the outermost axis,
        # that is the spatial components
        m_dot_R = np.tensordot(m, R, axes=1)
        # tensordot with axes=0 does a general outer product - we want no sum
        B = 3 * m_dot_R * R / norm_R**5 - np.tensordot(m, 1 / norm_R**3, axes=0)
        # include the physical constant
        B *= 1e-7
        return(B)

    def fieldreturn(self, n=5):
        '''
        Returns the local field for n radius neighbours
        '''
        grid = self.lattice
        field = np.zeros((self.side_len_x,self.side_len_y,3))
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                field[x,y,:] = self.Hlocal2(x, y, n=n)
        X = grid[:,:,0].flatten()
        Y = grid[:,:,1].flatten()
        Hx = field[:,:, 0].flatten()
        Hy = field[:,:, 1].flatten()
        Hz = field[:,:, 2].flatten()
        return(X,Y,Hx,Hy,Hz)

    def vertexCharge(self):
        '''
        Old Vertex charge determining function
        '''
        grid = self.lattice
        chargeGrid = np.zeros(((self.unit_cells_x-1)*(self.unit_cells_y-1), 3))     
        i = 0
        for y in range(2, self.side_len_y-2,2):
            for x in range(2, self.side_len_x-2,2):
                if grid[x,y,6] == 0:
                    m1 = grid[x-1,y,3]
                    m2 = grid[x+1,y,3]
                    m3 = grid[x,y+1,4]
                    m4 = grid[x,y-1,4]
                    charge = m1-m2-m3+m4
                    chargeGrid[i] = np.array([grid[x,y,0],grid[x,y,1],charge])
                    i = i+1
        return(chargeGrid)

    def vertexCharge2(self):
        '''
        Works you the vertex charge for square and Kagome.
        Should work on tetris and shakti but haven't test it yet
        '''
        grid = copy.deepcopy(self.lattice)
        for x in np.arange(0, self.side_len_x):
            for y in np.arange(0, self.side_len_y):
                if np.isnan(grid[x,y,8])!=True:
                    x1 = x - 1
                    x2 = x + 2
                    y1 = y - 1
                    y2 = y + 2

                    if x1<0:
                        x1 = 0
                    if x2>self.side_len_x:
                        x2 = self.side_len_x
                    if y1<0:
                        y1 = 0
                    if y2>self.side_len_y:
                        y2 = self.side_len_y
                    local = grid[x1:x2,y1:y2]
                    #print(local[:,:,3])
                    charge = (np.sum(local[0:2,0:2, 3:6])-np.sum(local[1:3,1:3, 3:6]))/4.
                    if self.type == 'kagome':
                        if x==0:
                            charge = np.sum(local[0,:,3]) -np.sum(local[1,:,3])+np.sum(local[:,0,4]) -np.sum(local[:,2,4])
                        elif x==self.side_len_x-1:
                            charge = np.sum(local[:,:,3]) -np.sum(local[:,:,3])+np.sum(local[:,0,4]) -np.sum(local[:,2,4])
                        elif (x-2)%4:
                            if (y-2)%4:
                                charge = np.sum(local[0,:,3]) -np.sum(local[1,:,3])+np.sum(local[:,0,4]) -np.sum(local[:,2,4])
                            else:
                                charge = np.sum(local[1,:,3]) -np.sum(local[2,:,3])+np.sum(local[:,0,4]) -np.sum(local[:,2,4])
                        elif (x)%4:
                            if (y-2)%4:
                                charge = np.sum(local[1,:,3]) -np.sum(local[2,:,3])+np.sum(local[:,0,4]) -np.sum(local[:,2,4])
                            else:
                                charge = np.sum(local[0,:,3]) -np.sum(local[1,:,3])+np.sum(local[:,0,4]) -np.sum(local[:,2,4])
                        if charge>3:
                            charge = 1
                        elif charge<-3:
                            charge = -1
                        else:
                            charge = 0

                    grid[x,y, 8] = charge
                    
                    #print(np.sum(np.multiply(local[:,:, 3:6]), np.array([[1,0],[0,-1]])))
                    #print(local)
                    
                    #local = grid[x-1:x+3,y-1:y+3,:]
                    #plt.quiver(grid[:,:,0].flatten(), grid[:,:,1].flatten(),grid[:,:,3].flatten(),grid[:,:,4].flatten(), angles='xy', scale_units='xy',  pivot = 'mid')
                    #plt.scatter(grid[:,:,0].flatten(), grid[:,:,0].flatten(), c = grid[:,:,8].flatten())
                    #plt.plot(grid[x,y,0],grid[x,y,1], 'o')
                    #plt.quiver(local[:,:,0].flatten(), local[:,:,1].flatten(),local[:,:,3].flatten(),local[:,:,4].flatten(), angles='xy', scale_units='xy',  pivot = 'mid')
                    #plt.show()
        self.lattice = grid
                    
    
    
    def fieldCalc(self,mag, r0, pos):
        '''
        Tells the class what type of field calculation method 
        you want to use for the rest of the simulation
        '''
        if self.interType == 'dipole':
            return(self.dipole(mag, r0, pos))
        if self.interType == 'dumbbell':
            return(self.dumbbell(mag, r0, pos))
    
    def Hlocal2(self, x,y,n =1):
        '''
        calculates the local field at position x, y including the 
        field with n radius with n=1 just including nearest neighbours
        '''
        Hl = []
        x1 = x - n
        x2 = x + n+1
        y1 = y - n
        y2 = y + n+1

        if x1<0:
            x1 = 0
        if x2>self.side_len_x:
            x2 = self.side_len_x -1
        if y1<0:
            y1 = 0
        if y2>self.side_len_y-1:
            y2 = self.side_len_y-1

        grid = self.lattice[x1:x2,y1:y2,:]
        m = grid[:,:,3:6]
        m = m.reshape(-1, m.shape[-1])
        r = grid[:,:,0:3]
        r = r.reshape(-1, r.shape[-1])
        r0 = self.lattice[x,y,0:3]

        for pos, mag in zip(r, m):
            if np.linalg.norm(pos-r0)/(n+1)<=1.0 and np.array_equal(pos, r0)!=True:
                Hl.append(self.fieldCalc(mag, r0, pos))
        return(sum(Hl))



    def localFieldHistogram(self, x, y, n, total, save = False):
        '''
        Plots a histogram of the local field at position x, y using n radius
        neighbours. Total is the number of times it calculates this and 
        then randomises the surrounding microstate
        '''
        field = []
        for c in np.arange(0,total):
            self.randomMag()
            test = self.Hlocal2(x,y,n=n)
            unit_vector = self.lattice[x,y,3:6]
            field.append(np.dot(np.array(test), unit_vector))
        #print(field)
        #(mu,sigma)=norm.fit(field)
        fig, ax1 = plt.subplots(1, 1)
        bin_number = np.ceil(np.sqrt(total))//2*2+1
        bins = np.linspace(min(field),max(field), num = bin_number)
        ax1.hist(field, normed=True, bins=bins, alpha=1.)
        #fit_hist = mlab.normpdf(bins, mu, sigma)
        #l = plt.plot(bins, fit_hist, 'r--', linewidth=2)
        ax1.set_ylabel('Count')
        ax1.set_xlabel('Field Strength along axis (T)')
        ax1.set_title(r'Local Field Strength Distribution - n=%.0f nearest neighbours' %(n))
        #s = '''     mean = %.2E
        #    std = %.2E
        #    range = %.2E''' %(mu, sigma, (max(field)-min(field))/2.)
        #plt.figtext(0.6,0.7,s)
        if save == True:
            folder = os.getcwd()+r'\\'+self.type+self.interType+r'_localFieldHistogram_length%.2Ewidth%.2Evgap%.2Ethick%.2E\\' \
            %(self.bar_length, self.bar_width, self.vertex_gap, self.bar_thickness)
            if not os.path.exists(folder):
                os.makedirs(folder)
            filename = os.path.join(folder, r'Histogram_x%.0fy%.0f_n%.0f_total%.0f' %(x, y, n, total))
            plt.savefig(filename+'.png')
            plt.savefig(filename+'.svg')
            np.savetxt(filename+'.csv', field, delimiter = ',')
            plt.close()
        else:
            plt.show()
        return(field)


    def effectiveCoercive(self, x, y, n):
        '''
        Calculates the effective coercive field at a give lattice location for n nearest neighbours
        '''
        localField = self.Hlocal2(x,y,n=n)
        unit_vector = self.lattice[x,y,3:6]
        dField = np.dot(np.array(localField), unit_vector)
        effectiveCoer = self.lattice[x,y,6]+dField
        return(effectiveCoer)

    def effectiveCoerciveHistogram(self, n, save = False):
        '''
        Works out what the effective Coercive field is for a given lattice.
        Calculates the dipolar field for n nearest neighbours
        Can be set to automatically save
        '''
        Coer = []
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if abs(self.lattice[x,y,6]) != 0:
                    Coer.append(self.effectiveCoercive(x,y,n))
        (mu,sigma)=norm.fit(Coer)
        fig, ax1 = plt.subplots(1, 1)
        bins = np.linspace(min(Coer),max(Coer), num = np.sqrt(len(Coer)))
        ax1.hist(Coer, normed=True, bins=bins, alpha=1.)
        y = mlab.normpdf(bins, mu, sigma)
        l = plt.plot(bins, y, 'r--', linewidth=2)
        ax1.set_ylabel('Count')
        ax1.set_xlabel('Field Strength along axis (T)')
        ax1.set_title('Effective Coercive Field - n='+str(n)+' nearest neighbours')
        if save == True:
            folder = os.getcwd()+r'\\'+self.type+r'_CoerciveFieldHistogram_length%.2Ewidth%.2Evgap%.2Ethick%.2E\\' \
            %(self.bar_length, self.bar_width, self.vertex_gap, self.bar_thickness)
            if not os.path.exists(folder):
                os.makedirs(folder)
            plt.savefig(folder+r'ECoerHistogram_n%.0f.png' %(n))
            plt.savefig(folder+r'ECoerHistogram_n%.0f.pdf' %(n))
            plt.close()
        else:
            plt.show()
        return(mu, sigma)

    def coerciveHistogram(self, n, save = False):
        '''
        Works out what the effective Coercive field is for a given lattice.
        Calculates the dipolar field for n nearest neighbours
        Can be set to automatically save
        '''
        Coer = []
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if abs(self.lattice[x,y,6]) != 0:
                    Coer.append(self.lattice[x,y,6])
        fig, ax1 = plt.subplots(1, 1)
        (mu,sigma)=norm.fit(Coer)
        bins = np.linspace(min(Coer),max(Coer), num = np.sqrt(len(Coer)))
        ax1.hist(Coer, normed=True, bins=bins, alpha=1.)
        y = mlab.normpdf(bins, mu, sigma)
        l = plt.plot(bins, y, 'r--', linewidth=2)
        ax1.set_ylabel('Count')
        ax1.set_xlabel('Field Strength along axis (T)')
        ax1.set_title('Coercive Field - n='+str(n)+' nearest neighbours')
        print(norm.fit(Coer))
        if save == True:
            folder = os.getcwd()+r'\\'+self.type+r'_CoerciveFieldHistogram_length%.2Ewidth%.2Evgap%.2Ethick%.2E\\' \
            %(self.bar_length, self.bar_width, self.vertex_gap, self.bar_thickness)
            if not os.path.exists(folder):
                os.makedirs(folder)
            plt.savefig(folder+r'CoerHistogram_n%.0f.png' %(n))
            plt.savefig(folder+r'CoerHistogram_n%.0f.pdf' %(n))
            plt.close()
        else:
            plt.show()

    def latticeFieldHistogram(self, n, save = False):
        '''
        Plots a histogram for the field on the lattice.
        Can be set to automatically save
        '''
        field = []
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if abs(self.lattice[x,y,6]) != 0:
                    test = self.Hlocal2(x,y,n=n)
                    unit_vector = self.lattice[x,y,3:6]
                    field.append(np.dot(np.array(test), unit_vector))
        #print(field)
        fig, ax1 = plt.subplots(1, 1)
        bin_number = np.ceil(np.sqrt(len(field)))//2*2+1
        bins = np.linspace(min(field),max(field), num = bin_number)
        ax1.hist(field, normed=True, bins=bins, alpha=1.)
        #fit_hist = mlab.normpdf(bins, mu, sigma)
        #l = plt.plot(bins, fit_hist, 'r--', linewidth=2)
        ax1.set_ylabel('Count')
        ax1.set_xlabel('Field Strength along axis (T)')
        ax1.set_title(r'Local Field Strength Distribution - n=%.0f nearest neighbours' %(n))
        if save == True:
            folder = os.getcwd()+r'\\'+self.type+self.interType+r'_localFieldLatticeHistogram_length%.2Ewidth%.2Evgap%.2Ethick%.2E\\' \
            %(self.bar_length, self.bar_width, self.vertex_gap, self.bar_thickness)
            if not os.path.exists(folder):
                os.makedirs(folder)
            filename = os.path.join(folder, r'Histogram_n%.0f' %(n))
            plt.savefig(filename+'.png')
            plt.savefig(filename+'.svg')
            np.savetxt(filename+'.csv', field, delimiter = ',')
            #plt.savefig(folder+r'Histogram_n%.2E.png' %(n))
            plt.close()
        else:
            plt.show()
        return(field)

    def vertexHistogram(self):
        '''
        Plots the vertex type as a histogram
        '''
        Vertex = self.vertexType()
        Type = Vertex[:,:,4].flatten()
        Type = Type[np.logical_not(np.isnan(Type))]
        fig, ax1 = plt.subplots(1, 1)
        ax1.hist(Type, normed=True, bins=np.linspace(0,5, num=6), alpha=1.)
        ax1.set_ylabel('Count')
        ax1.set_xlabel('Vertex Type')
        ax1.set_title('Vertex Type Distribuion')
        plt.show()

    def correlationHistogram(self):
        '''
        Plots the local correlation between surrounding spins as 
        a histogram
        '''
        Correlation = self.localCorrelation()
        Corr = Correlation[:,:,0].flatten()
        Corr = Corr[np.logical_not(np.isnan(Corr))]
        fig, ax1 = plt.subplots(1, 1)
        ax1.hist(Corr, normed=True, bins=np.linspace(0,1, num=21), alpha=1.)
        ax1.set_ylabel('Count')
        ax1.set_xlabel('Correlation')
        ax1.set_title('Local Correlation Distribuion')
        plt.show()


    def randomMag(self, seed = None):
        '''
        Randomises all the spins in the lattice
        '''
        State = np.random.RandomState(seed=seed)
        grid = self.lattice
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if grid[x,y,6] != 0:
                    if State.uniform(low=0.0, high=1.0)>0.5:
                        grid[x,y,3:6]=-1.*grid[x,y,3:6]
        grid[grid==-0.] = 0.
        self.lattice = grid

    def correlation(self, lattice1, lattice2):
        '''
        Returns the correlation between lattice1 and lattice2
        '''
        l1 = lattice1.returnLattice()
        l2 = lattice2.returnLattice()
        total = 0
        same = 0
        for x in range(0, self.side_len_x):
            for y in range(0, self.side_len_y):
                if l1[x,y,6]!=0:
                    if np.array_equal(l1[x,y, 3:6], l2[x,y,3:6]) ==True:
                        same+=1.0
                    total +=1.0
        #print("Same total:",same)
        #print("Absolute total:", total)
        #print('Correlation factor:',same/total)
        return(same/total)

    def netMagnetisation(self):
        '''
        returns the magnetisation in the x and y directions
        '''
        grid = copy.deepcopy(self.lattice)
        grid[grid[:,:,6]==0] = np.nan
        mx = grid[:,:,3].flatten()
        my = grid[:,:,4].flatten()
        return(np.array([np.nanmean(mx),np.nanmean(my)]))
        
    def monopoleDensity(self):
        '''
        Returns the monopole density of a square or kagome lattice
        '''
        #4in/0out have a charge of 1
        #3in/1out have a charge of 0.5
        #The density is then calculated by dividing by the total area minus the edges
        self.vertexCharge2()
        grid = self.lattice
        #magcharge = grid[:,:,8].flatten()
        return(np.nanmean(np.absolute(grid[:,:,8])))

    def vertexType(self):
        '''
        Only works for square
        Classifies the vertices into Type 1,2,3,4
        '''
        grid = copy.deepcopy(self.lattice)
        Vertex = np.zeros((self.side_len_x, self.side_len_y, 5))
        Type1 = np.array([-1,1,1,-1])
        Type21 = np.array([-1,-1,1,1])
        Type22 = np.array([1,1,1,1])
        Type3 = np.array([1,1,1,-1])
        Type3 = np.array([1,-1,1,1])
        Type3 = np.array([-1,1,1,1])
        Type3 = np.array([1,1,-1,1])
        Type4 = np.array([1,-1,1,-1])
        if self.type =='square':
            for x in np.arange(0, self.side_len_x):
                for y in np.arange(0, self.side_len_y):
                    Corr_local = []
                    if np.isnan(grid[x,y,8])!=True:
                        x1 = x - 3
                        x2 = x + 4
                        y1 = y - 3
                        y2 = y + 4

                        if x1<0:
                            x1 = 0
                        if x2>self.side_len_x:
                            x2 = self.side_len_x
                        if y1<0:
                            y1 = 0
                        if y2>self.side_len_y:
                            y2 = self.side_len_y
                        local = grid[x1:x2,y1:y2]
                        spin_code0 = np.array([grid[x+1,y,3],grid[x-1,y,3],grid[x,y+1,4],grid[x,y-1,4]])
                        Vertex[x,y,0:4] = spin_code0
                        if np.array_equal(Vertex[x,y,0:4],Type1) or np.array_equal(Vertex[x,y,0:4],-1.*Type1):
                            Vertex[x,y,4] = 1
                        elif np.array_equal(Vertex[x,y,0:4],Type4) or np.array_equal(Vertex[x,y,0:4], -1.*Type4):
                            Vertex[x,y,4] = 4
                        elif np.array_equal(Vertex[x,y,0:4], Type21) or np.array_equal(Vertex[x,y,0:4], -1.*Type21) or np.array_equal(Vertex[x,y,0:4],Type22) or np.array_equal(Vertex[x,y,0:4],-1.*Type22):
                            Vertex[x,y,4] = 2
                        else:
                            Vertex[x,y,4] = 3
                    else:
                        Vertex[x,y,:] = np.array([np.nan, np.nan, np.nan, np.nan, np.nan])
        if self.type == 'kagome':
            Vertex = np.zeros((self.side_len_x, self.side_len_y, 5))
        return(Vertex)

    def vertexTypeMap(self):
        '''
        Only works with square
        '''
        Vertex = self.vertexType()
        X = self.lattice[:,:,0].flatten()
        Y = self.lattice[:,:,1].flatten()
        z = self.lattice[:,:,2].flatten()
        Mx = self.lattice[:,:,3].flatten()
        My = self.lattice[:,:,4].flatten()
        Mz = self.lattice[:,:,5].flatten()
        Hc = self.lattice[:,:,6].flatten()
        C = self.lattice[:,:,7].flatten()
        charge = self.lattice[:,:,8].flatten()
        Type = Vertex[:,:,4].flatten()
        fig = plt.figure(figsize=(6,6))
        ax = fig.add_subplot(111)
        ax.set_xlim([-1*self.unit_cell_len, np.max(X)+self.unit_cell_len])
        ax.set_ylim([-1*self.unit_cell_len, np.max(Y)+self.unit_cell_len])
        graph = ax.scatter(X,Y,c = Vertex[:,:,4], marker = 'o', cmap = cm.plasma, zorder=2)
        cb2 = fig.colorbar(graph, fraction=0.046, pad=0.04, ax = ax)
        cb2.locator = MaxNLocator(nbins = 5)
        cb2.update_ticks()
        ax.quiver(X,Y,Mx,My,angles='xy', scale_units='xy',  pivot = 'mid')
        plt.show()

    def vertexTypePercentage(self):
        '''
        Calculates the percentage of each vertex type
        Only works with square
        '''
        Vertex= self.vertexType()
        Type1 = np.nansum(Vertex[:,:,4]==1.)
        Type2 = np.nansum(Vertex[:,:,4]==2.)
        Type3 = np.nansum(Vertex[:,:,4]==3.)
        Type4 = np.nansum(Vertex[:,:,4]==4.)
        total = np.nansum([Type1, Type2, Type3, Type4])
        #print(total, Type1,Type2,Type3,Type4)
        vertices = [Type1/total, Type2/total, Type3/total, Type4/total]
        #print(vertices)
        return(vertices)

    def localCorrelation(self):
        '''
        Looks at all the vertices adjacent to each vertex and asigns a correlation factor
        based on how similar they are
        Only works for square Lattice
        '''
        grid = copy.deepcopy(self.lattice)
        Correlation = np.zeros((self.side_len_x, self.side_len_y, 1))
        for x in np.arange(0, self.side_len_x):
            for y in np.arange(0, self.side_len_y):
                Corr_local = []
                if np.isnan(grid[x,y,8])!=True:
                    x1 = x - 3
                    x2 = x + 4
                    y1 = y - 3
                    y2 = y + 4

                    if x1<0:
                        x1 = 0
                    if x2>self.side_len_x:
                        x2 = self.side_len_x
                    if y1<0:
                        y1 = 0
                    if y2>self.side_len_y:
                        y2 = self.side_len_y
                    local = grid[x1:x2,y1:y2]
                    spin_code0 = np.array([grid[x+1,y,3],grid[x-1,y,3],grid[x,y+1,4],grid[x,y-1,4]])

                    #print(np.sum(np.multiply(local[:,:, 3:6]), np.array([[1,0],[0,-1]])))
                    #print(local)
                    for i in np.arange(x1,x2):
                        for j in np.arange(y1,y2):
                            if np.isnan(grid[i,j,8])!=True:
                                spin_code = np.array([grid[i+1,j,3],grid[i-1,j,3],grid[i,j+1,4],grid[i,j-1,4]])
                                Corr_local.append(np.sum(np.equal(spin_code,spin_code0))/np.size(spin_code))
                    Corr = (np.sum(np.array(Corr_local))-1.)/(np.size(Corr_local)-1.)
                    Correlation[x,y,0] = Corr
                else:
                    Correlation[x,y,0] = np.nan
                    #local = grid[x-1:x+3,y-1:y+3,:]
                    #plt.quiver(grid[:,:,0].flatten(), grid[:,:,1].flatten(),grid[:,:,3].flatten(),grid[:,:,4].flatten(), angles='xy', scale_units='xy',  pivot = 'mid')
                    #plt.scatter(grid[:,:,0].flatten(), grid[:,:,0].flatten(), c = grid[:,:,8].flatten())
                    #plt.plot(grid[x,y,0],grid[x,y,1], 'o')
                    #plt.quiver(local[:,:,0].flatten(), local[:,:,1].flatten(),local[:,:,3].flatten(),local[:,:,4].flatten(), angles='xy', scale_units='xy',  pivot = 'mid')
                    #plt.show()
        X = grid[:,:,0].flatten()
        Y = grid[:,:,1].flatten()
        z = grid[:,:,2].flatten()
        Mx = grid[:,:,3].flatten()
        My = grid[:,:,4].flatten()
        Mz = grid[:,:,5].flatten()
        Hc = grid[:,:,6].flatten()
        C = grid[:,:,7].flatten()
        charge = grid[:,:,8].flatten()
        fig = plt.figure(figsize=(6,6))
        ax = fig.add_subplot(111)
        ax.set_xlim([-1*self.unit_cell_len, np.max(X)+self.unit_cell_len])
        ax.set_ylim([-1*self.unit_cell_len, np.max(Y)+self.unit_cell_len])
        graph = ax.scatter(X,Y,c = Correlation[:,:,0], marker = 'o', cmap = cm.plasma, zorder=2)
        cb2 = fig.colorbar(graph, fraction=0.046, pad=0.04, ax = ax)
        cb2.locator = MaxNLocator(nbins = 5)
        cb2.update_ticks()
        ax.quiver(X,Y,Mx,My,angles='xy', scale_units='xy',  pivot = 'mid')
        plt.show()
        return(Correlation)

   
    def flipSpin(self, x,y):
        '''
        Will flips a single spin in coordinates (x,y)
        '''
        self.lattice[x,y,3:6]=-1.*self.lattice[x,y,3:6]
        self.lattice[self.lattice==-0.] = 0.

    def returnLattice(self):
        '''
        Returns the lattice in its current state
        '''
        return(self.lattice)

    '''
    Change the parameters using these functions
    '''

    def changeLength(self, newbar_length):
        '''
        Charges the bar length in the rpm class to the newbar_length
        '''
        self.bar_length = newbar_length
        self.unit_cell_len = (self.bar_length+self.vertex_gap)/2

    def changeWidth(self, newbar_width):
        self.bar_width = newbar_width

    def changeinteractionType(self, interType='dumbbell'):
        if interType == 'dipole':
            self.interType = 'dipole'
        if interType == 'dumbbell':
            self.interType = 'dumbbell'

    def changeVertexgap(self, newvertex_gap):
        '''
        changes the vertex gap in the rpm class to the newvertex_gap
        '''
        self.vertex_gap = newvertex_gap
        self.unit_cell_len = (self.bar_length+self.vertex_gap)/2

    def changeMagnetisation(self, new_magnetisation):
        '''
        changes the magnetisation gap in the rpm class to the new_magnetisation
        '''
        self.magnetisation = new_magnetisation

    def fieldSweepAnalysis(self, folder):
        '''
        Plots the magnetisation, correlation, monopole density, and vertex population
        graphs for the summary data
        '''
        parameters_list = []
        Hmax_list,Htheta_list, steps_list, n_list, loops_list = [],[],[],[],[]
        Hc_list = []
        Hc_std_list = []
        field_steps_list = []
        q_list = []
        mag_list = []
        monopole_list = []
        vertex_list = []
        for root, dirs, files in os.walk(folder):
            for file in files:
                if 'RPMStateInfo' in file:
                    npzfile = np.load(os.path.join(root,file))
                    parameters_list.append(npzfile['arr_0'])
                    print(parameters_list)
                    Hmax_list.append(npzfile['arr_0'][0])
                    steps_list.append(npzfile['arr_0'][1])
                    Htheta_list.append(npzfile['arr_0'][2])
                    n_list.append(npzfile['arr_0'][3])
                    loops_list.append(npzfile['arr_0'][4])
                    Hc_list.append(npzfile['arr_0'][5])
                    Hc_std_list.append(npzfile['arr_0'][6])
                    field_steps_list.append(npzfile['arr_1'])
                    q_list.append(npzfile['arr_2'])
                    mag_list.append(npzfile['arr_3'])
                    monopole_list.append(npzfile['arr_4'])
                    vertex_list.append(npzfile['arr_5'])
        for Hmax, loops, steps, q, mag, monopole, vertex in zip(Hmax_list, \
                        loops_list, steps_list, q_list, mag_list, monopole_list, vertex_list):
            self.plotCorrelation(folder, q, Hmax, loops, steps)
            self.plotMagnetisation(folder, mag, Hmax, loops, steps)
            #self.plotMonopole(folder, monopole, Hmax, loops, steps)
            #self.plotVertex(folder, vertex, Hmax, loops, steps)
        plt.show()

    def plotCorrelation(self, folder, q, Hmax, loops, steps):
        '''
        Plots the correlation through the field sweep as a function
        of number of field steps
        '''
        corr = plt.figure('Correlation')
        ax_c = corr.add_subplot(111)
        ax_c.plot(q,'.', label = Hmax)
        plt.ylabel('Correlation')
        plt.xlabel('Number of field steps')
        for i in np.arange(1, loops):
            plt.axvline(i*(4*(steps+1)-1), color = 'k')
        plt.legend()
        plt.savefig(os.path.join(folder, 'CorrelationFieldsteps'))

    def plotMagnetisation(self, folder, mag, Hmax, loops, steps):
        '''
        Plots the magnetisation in both x and y through the field sweep as a function
        of number of field steps
        '''
        mag_plotx = plt.figure('Magnetisation')
        ax_mx = mag_plotx.add_subplot(111)
        ax_mx.plot(2*mag[:,0],'.', label = Hmax)
        plt.ylabel('Magnetisation (x-dir)')
        plt.xlabel('Number of field steps')
        for i in np.arange(1, loops):
            plt.axvline(i*(4*(steps+1)-1), color = 'k')
        plt.legend()
        plt.savefig(os.path.join(folder, 'MagxFieldsteps'))
        mag_ploty = plt.figure('Magnetisation')
        ax_my = mag_ploty.add_subplot(111)
        ax_my.plot(2*mag[:,1],'.', label = Hmax)
        for i in np.arange(1, loops):
            plt.axvline(i*(4*(steps+1)-1), color = 'k')
        plt.ylabel('Magnetisation (y-dir)')
        plt.xlabel('Number of field steps')
        plt.legend()
        plt.savefig(os.path.join(folder, 'MagyFieldsteps'))

    def plotMonopole(self, folder, monopole, Hmax, loops, steps):
        '''
        Plots the monopole density through the field sweep as a function
        of number of field steps
        '''
        mono = plt.figure('Monopole')
        ax_m = mono.add_subplot(111)
        ax_m.plot(monopole, '.', label = Hmax)
        plt.ylabel('Monopole density')
        plt.xlabel('Number of field steps')
        for i in np.arange(1, loops):
            plt.axvline(i*(4*(steps+1)-1), color = 'k')
        plt.legend()
        plt.savefig(os.path.join(folder, 'MonopoleFieldsteps'))

    def plotVertex(self, folder, vertex, Hmax, loops, steps):
        '''
        Plots the vertex type percentage through the field sweep as a function
        of number of field steps
        '''
        vert = plt.figure('Vertex')
        ax_v = vert.add_subplot(111)
        ax_v.plot(vertex[:,0],'.', label = 'Type 1')
        ax_v.plot(vertex[:,1],'.', label = 'Type 2')
        ax_v.plot(vertex[:,2],'.', label = 'Type 3')
        ax_v.plot(vertex[:,3],'.', label = 'Type 4')
        plt.ylabel('Vertex Percentage')
        plt.xlabel('Number of field steps')
        for i in np.arange(1, loops):
            plt.axvline(i*(4*(steps+1)-1), color = 'k')
        plt.legend()
        plt.savefig(os.path.join(folder, 'VertexFieldsteps'))


class ASI_thermal(ASI_RPM):
    '''
    To simulate thermal Artificial spin ice
    Still working on it
    '''
    def __init__(self, temp, K_ani, rate0, Happ, Htheta, n = 3):
        self.temp = temp
        self.K_ani = K_ani
        self.rate0 = rate0
        self.Happ = Happ
        self.Htheta = Htheta
        self.n = n

    def changeTemp(self, temp_new):
        self.temp = temp_new

    def changeK_ani(self, K_ani_new):
        self.K_ani = K_ani_new

    def changeRate0(self, rate0_new):
        self.rate0 = rate0_new

    def changeHapp(self, Happ_new):
        self.Happ = Happ_new

    def changeHapp(self, Htheta_new):
        self.Htheta = Htheta_new

    def thermalEnergy(self):
        k_B = 1.38064852e-23
        return(k_B*self.temp)

    def demagEnergy(self,x,y):
        fieldApplied = self.Happ*np.array([np.cos(self.Htheta), np.sin(self.Htheta), 0.])
        fieldLocal = self.Hlocal(x,y, self.n)
        field = fieldLocal+fieldApplied
        demag = -1*4e-7*np.pi*np.dot(self.lattice[x,y,3:6], field)
        return(demag)

    def demagEnergyDiff(self, x, y):
        E_init = self.demagEnergy(x, y)
        self.flipSpin(x,y)
        E_final = self.demagEnergy(x, y)
        self.flipSpin(x,y)
        return(E_final - E_init)

    def anisotropyEnergy(self):
        volume = self.width*self.bar_thickness*self.bar_length
        return(self.K_ani*volume)

    def flipProb(self, x,y):
        thermal_energy = np.sum(self.thermalEnergy())
        deltaE = np.sum(self.anisotropyEnergy(),self.demagEnergyDiff(x,y))
        prob = np.exp(-deltaE/thermal_energy)
        return(self.rate0*prob)

    def thermalMC(self, rate0):
        positions = []
        rates = np.zeros((self.side_len_x, self.side_len_y))
        for x in np.arange(0, self.side_len_x):
            for y in np.arange(0, self.side_len_y):
                if abs(self.lattice[x,y,6]) != 0:
                    rate = self.flipProb(x,y)
       








        



'''
Hc = 0.062
Hc_std = 0.05
bar_length = 220e-9
vertex_gap = 1e-7
bar_thickness = 25e-9
bar_width = 80e-9
magnetisation = 800e3
'''
'''
#Graphing and save/load test
kagomeLattice = ASI_RPM(10, 10)
kagomeLattice.kagome()
filename = 'KagomeTest.npy'
kagomeLattice.save(os.path.join(os.getcwd(),filename))
kagomeLattice.randomMag()
kagomeLattice.graph()
#kagomeLattice.load(os.path.join(os.getcwd(),filename))
#kagomeLattice.graph()
kagomeLattice.fieldplot()
plt.show()
'''

#field sweep test, count different test
'''
angle = 45
Hamp = 1.3*Hc
squareLattice = ASI_RPM(6, 6, bar_length = bar_length,\
 vertex_gap = vertex_gap, bar_thickness = bar_thickness,\
 bar_width = bar_width, magnetisation = magnetisation)
squareLattice.square(Hc_mean=Hc, Hc_std=Hc_std)
print(squareLattice.monopoleDensity())
print(squareLattice.netMagnetisation())
squareLattice.randomMag()
print(squareLattice.monopoleDensity())
squareLattice.randomMag()
print(squareLattice.monopoleDensity())
'''
'''
print(squareLattice.netMagnetisation())
#squareLattice.randomMag()
#squareLattice.vertexCharge()
squareLattice.graphCharge()
squareLattice.graph()
#squareLattice.fieldplot()
#plt.show()
Hmax = Hamp/np.cos(np.pi*angle/180)
steps = 20
field_steps = np.linspace(0,Hmax,steps+1)
field_steps = np.append(field_steps, np.linspace(Hmax,-Hmax,2*steps+1))
field_steps = np.append(field_steps, np.linspace(-Hmax,0,steps+1))
q, Mag = squareLattice.fieldsweep(Hamp/np.cos(np.pi*angle/180),20,angle, n = 3, loops = 2)
fig = plt.figure()
plt.plot(np.tile(field_steps,2),Mag)
plt.show()
#squareLattice.graph()
#squareLattice.fieldplot()


#def makePlot(x,y):
#    fig, ax =plt.subplots()
#    ax.plot(x, y)

#makePlot(np.arange(1, len(q)+1), q)

plt.show()      #makes sure this is at the end of the code
'''